#!/usr/bin/env python3.8
# @generated by pegen from src/pegen/metagrammar.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
from ast import literal_eval

from pegen.grammar import (
    Alt,
    Cut,
    Forced,
    Gather,
    Group,
    Item,
    Lookahead,
    LookaheadOrCut,
    MetaTuple,
    MetaList,
    NameLeaf,
    NamedItem,
    NamedItemList,
    NegativeLookahead,
    Opt,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    RuleList,
    RuleName,
    Grammar,
    StringLeaf,
)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Grammar]:
        # start: grammar $
        mark = self._mark()
        while True:
            _last = self.grammar()
            grammar = _last
            if not _last: break
            _last = self.expect('ENDMARKER')
            _endmarker = _last
            if not _last: break
            return grammar;
        self._reset(mark)
        return None;

    @memoize
    def grammar(self) -> Optional[Grammar]:
        # grammar: metas rules | rules
        mark = self._mark()
        while True:
            _last = self.metas()
            metas = _last
            if not _last: break
            _last = self.rules()
            rules = _last
            if not _last: break
            return Grammar ( rules , metas );
        self._reset(mark)
        while True:
            _last = self.rules()
            rules = _last
            if not _last: break
            return Grammar ( rules , [] );
        self._reset(mark)
        return None;

    @memoize
    def metas(self) -> Optional[MetaList]:
        # metas: meta metas | meta
        mark = self._mark()
        while True:
            _last = self.meta()
            meta = _last
            if not _last: break
            _last = self.metas()
            metas = _last
            if not _last: break
            return [meta] + metas;
        self._reset(mark)
        while True:
            _last = self.meta()
            meta = _last
            if not _last: break
            return [meta];
        self._reset(mark)
        return None;

    @memoize
    def meta(self) -> Optional[MetaTuple]:
        # meta: "@" NAME NEWLINE | "@" NAME NAME NEWLINE | "@" NAME STRING NEWLINE
        mark = self._mark()
        while True:
            _last = self.expect("@")
            literal = _last
            if not _last: break
            _last = self.name()
            name = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            return ( name . string , None );
        self._reset(mark)
        while True:
            _last = self.expect("@")
            literal = _last
            if not _last: break
            _last = self.name()
            a = _last
            if not _last: break
            _last = self.name()
            b = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            return ( a . string , b . string );
        self._reset(mark)
        while True:
            _last = self.expect("@")
            literal = _last
            if not _last: break
            _last = self.name()
            name = _last
            if not _last: break
            _last = self.string()
            string = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            return ( name . string , literal_eval ( string . string ) );
        self._reset(mark)
        return None;

    @memoize
    def rules(self) -> Optional[RuleList]:
        # rules: rule rules | rule
        mark = self._mark()
        while True:
            _last = self.rule()
            rule = _last
            if not _last: break
            _last = self.rules()
            rules = _last
            if not _last: break
            return [rule] + rules;
        self._reset(mark)
        while True:
            _last = self.rule()
            rule = _last
            if not _last: break
            return [rule];
        self._reset(mark)
        return None;

    @memoize
    def rule(self) -> Optional[Rule]:
        # rule: rulename memoflag? ":" alts NEWLINE INDENT more_alts DEDENT | rulename memoflag? ":" NEWLINE INDENT more_alts DEDENT | rulename memoflag? ":" alts NEWLINE
        mark = self._mark()
        while True:
            _last = self.rulename()
            rulename = _last
            if not _last: break
            _last = self.memoflag(),
            opt = _last[0]
            _last = True
            if not _last: break
            _last = self.expect(":")
            literal = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            _last = self.expect('INDENT')
            _indent = _last
            if not _last: break
            _last = self.more_alts()
            more_alts = _last
            if not _last: break
            _last = self.expect('DEDENT')
            _dedent = _last
            if not _last: break
            return Rule ( rulename [0] , rulename [1] , Rhs ( alts . alts + more_alts . alts ) , memo = opt );
        self._reset(mark)
        while True:
            _last = self.rulename()
            rulename = _last
            if not _last: break
            _last = self.memoflag(),
            opt = _last[0]
            _last = True
            if not _last: break
            _last = self.expect(":")
            literal = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            _last = self.expect('INDENT')
            _indent = _last
            if not _last: break
            _last = self.more_alts()
            more_alts = _last
            if not _last: break
            _last = self.expect('DEDENT')
            _dedent = _last
            if not _last: break
            return Rule ( rulename [0] , rulename [1] , more_alts , memo = opt );
        self._reset(mark)
        while True:
            _last = self.rulename()
            rulename = _last
            if not _last: break
            _last = self.memoflag(),
            opt = _last[0]
            _last = True
            if not _last: break
            _last = self.expect(":")
            literal = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            return Rule ( rulename [0] , rulename [1] , alts , memo = opt );
        self._reset(mark)
        return None;

    @memoize
    def rulename(self) -> Optional[RuleName]:
        # rulename: NAME annotation | NAME
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            _last = self.annotation()
            annotation = _last
            if not _last: break
            return ( name . string , annotation );
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            return ( name . string , None );
        self._reset(mark)
        return None;

    @memoize
    def memoflag(self) -> Optional[str]:
        # memoflag: '(' "memo" ')'
        mark = self._mark()
        while True:
            _last = self.expect('(')
            literal = _last
            if not _last: break
            _last = self.expect("memo")
            literal_1 = _last
            if not _last: break
            _last = self.expect(')')
            literal_2 = _last
            if not _last: break
            return "memo";
        self._reset(mark)
        return None;

    @memoize
    def alts(self) -> Optional[Rhs]:
        # alts: alt "|" alts | alt
        mark = self._mark()
        while True:
            _last = self.alt()
            alt = _last
            if not _last: break
            _last = self.expect("|")
            literal = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            return Rhs ( [alt] + alts . alts );
        self._reset(mark)
        while True:
            _last = self.alt()
            alt = _last
            if not _last: break
            return Rhs ( [alt] );
        self._reset(mark)
        return None;

    @memoize
    def more_alts(self) -> Optional[Rhs]:
        # more_alts: "|" alts NEWLINE more_alts | "|" alts NEWLINE
        mark = self._mark()
        while True:
            _last = self.expect("|")
            literal = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            _last = self.more_alts()
            more_alts = _last
            if not _last: break
            return Rhs ( alts . alts + more_alts . alts );
        self._reset(mark)
        while True:
            _last = self.expect("|")
            literal = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            _last = self.expect('NEWLINE')
            _newline = _last
            if not _last: break
            return Rhs ( alts . alts );
        self._reset(mark)
        return None;

    @memoize
    def alt(self) -> Optional[Alt]:
        # alt: items '$' action | items '$' | items action | items
        mark = self._mark()
        while True:
            _last = self.items()
            items = _last
            if not _last: break
            _last = self.expect('$')
            literal = _last
            if not _last: break
            _last = self.action()
            action = _last
            if not _last: break
            return Alt ( items + [NamedItem ( None , NameLeaf ( 'ENDMARKER' ) )] , action = action );
        self._reset(mark)
        while True:
            _last = self.items()
            items = _last
            if not _last: break
            _last = self.expect('$')
            literal = _last
            if not _last: break
            return Alt ( items + [NamedItem ( None , NameLeaf ( 'ENDMARKER' ) )] , action = None );
        self._reset(mark)
        while True:
            _last = self.items()
            items = _last
            if not _last: break
            _last = self.action()
            action = _last
            if not _last: break
            return Alt ( items , action = action );
        self._reset(mark)
        while True:
            _last = self.items()
            items = _last
            if not _last: break
            return Alt ( items , action = None );
        self._reset(mark)
        return None;

    @memoize
    def items(self) -> Optional[NamedItemList]:
        # items: named_item items | named_item
        mark = self._mark()
        while True:
            _last = self.named_item()
            named_item = _last
            if not _last: break
            _last = self.items()
            items = _last
            if not _last: break
            return [named_item] + items;
        self._reset(mark)
        while True:
            _last = self.named_item()
            named_item = _last
            if not _last: break
            return [named_item];
        self._reset(mark)
        return None;

    @memoize
    def named_item(self) -> Optional[NamedItem]:
        # named_item: NAME annotation '=' ~ item | NAME '=' ~ item | item | forced_atom | lookahead
        mark = self._mark()
        cut = False
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            _last = self.annotation()
            annotation = _last
            if not _last: break
            _last = self.expect('=')
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.item()
            item = _last
            if not _last: break
            return NamedItem ( name . string , item , annotation );
        self._reset(mark)
        if cut:
            return None;
        cut = False
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            _last = self.expect('=')
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.item()
            item = _last
            if not _last: break
            return NamedItem ( name . string , item );
        self._reset(mark)
        if cut:
            return None;
        while True:
            _last = self.item()
            item = _last
            if not _last: break
            return NamedItem ( None , item );
        self._reset(mark)
        while True:
            _last = self.forced_atom()
            it = _last
            if not _last: break
            return NamedItem ( None , it );
        self._reset(mark)
        while True:
            _last = self.lookahead()
            it = _last
            if not _last: break
            return NamedItem ( None , it );
        self._reset(mark)
        return None;

    @memoize
    def forced_atom(self) -> Optional[LookaheadOrCut]:
        # forced_atom: '&' '&' ~ atom
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect('&')
            literal = _last
            if not _last: break
            _last = self.expect('&')
            literal_1 = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.atom()
            atom = _last
            if not _last: break
            return Forced ( atom );
        self._reset(mark)
        if cut:
            return None;
        return None;

    @memoize
    def lookahead(self) -> Optional[LookaheadOrCut]:
        # lookahead: '&' ~ atom | '!' ~ atom | '~'
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect('&')
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.atom()
            atom = _last
            if not _last: break
            return PositiveLookahead ( atom );
        self._reset(mark)
        if cut:
            return None;
        cut = False
        while True:
            _last = self.expect('!')
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.atom()
            atom = _last
            if not _last: break
            return NegativeLookahead ( atom );
        self._reset(mark)
        if cut:
            return None;
        while True:
            _last = self.expect('~')
            literal = _last
            if not _last: break
            return Cut ( );
        self._reset(mark)
        return None;

    @memoize
    def item(self) -> Optional[Item]:
        # item: '[' ~ alts ']' | atom '?' | atom '*' | atom '+' | atom '.' atom '+' | atom
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect('[')
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            _last = self.expect(']')
            literal_1 = _last
            if not _last: break
            return Opt ( alts );
        self._reset(mark)
        if cut:
            return None;
        while True:
            _last = self.atom()
            atom = _last
            if not _last: break
            _last = self.expect('?')
            literal = _last
            if not _last: break
            return Opt ( atom );
        self._reset(mark)
        while True:
            _last = self.atom()
            atom = _last
            if not _last: break
            _last = self.expect('*')
            literal = _last
            if not _last: break
            return Repeat0 ( atom );
        self._reset(mark)
        while True:
            _last = self.atom()
            atom = _last
            if not _last: break
            _last = self.expect('+')
            literal = _last
            if not _last: break
            return Repeat1 ( atom );
        self._reset(mark)
        while True:
            _last = self.atom()
            sep = _last
            if not _last: break
            _last = self.expect('.')
            literal = _last
            if not _last: break
            _last = self.atom()
            node = _last
            if not _last: break
            _last = self.expect('+')
            literal_1 = _last
            if not _last: break
            return Gather ( sep , node );
        self._reset(mark)
        while True:
            _last = self.atom()
            atom = _last
            if not _last: break
            return atom;
        self._reset(mark)
        return None;

    @memoize
    def atom(self) -> Optional[Plain]:
        # atom: '(' ~ alts ')' | NAME | STRING
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect('(')
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.alts()
            alts = _last
            if not _last: break
            _last = self.expect(')')
            literal_1 = _last
            if not _last: break
            return Group ( alts );
        self._reset(mark)
        if cut:
            return None;
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            return NameLeaf ( name . string );
        self._reset(mark)
        while True:
            _last = self.string()
            string = _last
            if not _last: break
            return StringLeaf ( string . string );
        self._reset(mark)
        return None;

    @memoize
    def action(self) -> Optional[str]:
        # action: "{" ~ target_atoms "}"
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("{")
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.target_atoms()
            target_atoms = _last
            if not _last: break
            _last = self.expect("}")
            literal_1 = _last
            if not _last: break
            return target_atoms;
        self._reset(mark)
        if cut:
            return None;
        return None;

    @memoize
    def annotation(self) -> Optional[str]:
        # annotation: "[" ~ target_atoms "]"
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.target_atoms()
            target_atoms = _last
            if not _last: break
            _last = self.expect("]")
            literal_1 = _last
            if not _last: break
            return target_atoms;
        self._reset(mark)
        if cut:
            return None;
        return None;

    @memoize
    def target_atoms(self) -> Optional[str]:
        # target_atoms: target_atom target_atoms | target_atom
        mark = self._mark()
        while True:
            _last = self.target_atom()
            target_atom = _last
            if not _last: break
            _last = self.target_atoms()
            target_atoms = _last
            if not _last: break
            return target_atom + " " + target_atoms;
        self._reset(mark)
        while True:
            _last = self.target_atom()
            target_atom = _last
            if not _last: break
            return target_atom;
        self._reset(mark)
        return None;

    @memoize
    def target_atom(self) -> Optional[str]:
        # target_atom: "{" ~ target_atoms? "}" | "[" ~ target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" | ":" | !"}" !"]" OP
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("{")
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.target_atoms(),
            atoms = _last[0]
            _last = True
            if not _last: break
            _last = self.expect("}")
            literal_1 = _last
            if not _last: break
            return "{" + ( atoms or "" ) + "}";
        self._reset(mark)
        if cut:
            return None;
        cut = False
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last: break
            _last = True
            cut = _last
            if not _last: break
            _last = self.target_atoms(),
            atoms = _last[0]
            _last = True
            if not _last: break
            _last = self.expect("]")
            literal_1 = _last
            if not _last: break
            return "[" + ( atoms or "" ) + "]";
        self._reset(mark)
        if cut:
            return None;
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            _last = self.expect("*")
            literal = _last
            if not _last: break
            return name . string + "*";
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last: break
            return name . string;
        self._reset(mark)
        while True:
            _last = self.number()
            number = _last
            if not _last: break
            return number . string;
        self._reset(mark)
        while True:
            _last = self.string()
            string = _last
            if not _last: break
            return string . string;
        self._reset(mark)
        while True:
            _last = self.expect("?")
            literal = _last
            if not _last: break
            return "?";
        self._reset(mark)
        while True:
            _last = self.expect(":")
            literal = _last
            if not _last: break
            return ":";
        self._reset(mark)
        while True:
            _last = self.negative_lookahead(self.expect, "}")
            if not _last: break
            _last = self.negative_lookahead(self.expect, "]")
            if not _last: break
            _last = self.op()
            op = _last
            if not _last: break
            return op . string;
        self._reset(mark)
        return None;

    KEYWORDS = ()
    SOFT_KEYWORDS = ('memo',)


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
